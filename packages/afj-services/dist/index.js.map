{"version":3,"sources":["../index.ts","../src/ledgerServices.ts","../src/agentConfigs.ts","../src/baseService.ts","../src/agentServices.ts","../src/credentialServices.ts","../src/connectionServices.ts"],"sourcesContent":["export * as LedgerServices from \"./src/ledgerServices\";\nexport * as AgentConfigServices from \"./src/agentConfigs\";\nexport { AgentService } from \"./src/agentServices\";\nexport { CredentialService } from \"./src/credentialServices\";\nexport { ConnectionService } from \"./src/connectionServices\";\n","import { RequestInfo, ResponseInit } from \"node-fetch\";\n\n// For network request purposes only.\nconst fetch = (url: RequestInfo, init?: ResponseInit) =>\n\timport(\"node-fetch\").then(({ default: fetch }) => fetch(url, init));\n\n// Hyperledger Indy networks will return the genesis file as a plaintext response\nexport async function fetchGenesisTransaction(\n\tledgerUrl: string\n): Promise<string> {\n\tconsole.log(\n\t\t\"[ledger.services] Fetching Genesis Transaction for Indy Ledger..\"\n\t);\n\tconst res = await fetch(ledgerUrl);\n\treturn await res.text();\n}\n","import { Agent, InitConfig, IndyPoolConfig } from \"@aries-framework/core\";\nimport { agentDependencies } from \"@aries-framework/node\";\nimport { fetchGenesisTransaction } from \"./ledgerServices\";\n\ninterface RequiredAgentConfig extends InitConfig {\n\twalletConfig: InitConfig[\"walletConfig\"];\n}\ninterface CreateAgentConfigProps extends RequiredAgentConfig {}\nexport async function createAgentConfig({ ...args }: CreateAgentConfigProps) {\n\tconsole.log(\"[agent.config] Creating Agent Config..\");\n\n\tconst config: InitConfig = {\n\t\t...args,\n\t};\n\n\treturn config;\n}\n\ntype IndyLedgerConfig = {\n\tid: string;\n\tledgerUrl: string;\n\tindyNamespace: string;\n\tisProduction: boolean;\n};\ninterface CreateAgentProps {\n\tconfig: InitConfig;\n\tindyLedgers: IndyLedgerConfig[];\n}\n\nconst genesisTransactionsCache = new WeakMap<IndyLedgerConfig, string>();\nexport async function createAgent({ config, indyLedgers }: CreateAgentProps) {\n\tconsole.log(\"[agent.config] Creating Agent..\");\n\n\tlet ledgers: IndyPoolConfig[] = [];\n\tfor (const key in indyLedgers) {\n\t\tconst indyLedger = indyLedgers[key];\n\t\tif (genesisTransactionsCache.has(indyLedger)) {\n\t\t\tconsole.log(\"[agent.configs] Found Genesis Transaction in cache.\");\n\n\t\t\tif (\"ledgerUrl\" in indyLedger) delete indyLedger.ledgerUrl;\n\n\t\t\tledgers.push({\n\t\t\t\t...indyLedger,\n\t\t\t\tgenesisTransactions: genesisTransactionsCache.get(indyLedger),\n\t\t\t});\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Fetching Genesis transaction file via HTTP GET request\n\t\tconst genesisTransactions = await fetchGenesisTransaction(\n\t\t\tindyLedger.ledgerUrl\n\t\t);\n\t\tif (typeof genesisTransactions !== \"string\") {\n\t\t\tconsole.log(\"[agent.configs] Failed fetching genesis transactions file.\");\n\t\t\tbreak;\n\t\t}\n\n\t\tgenesisTransactionsCache.set(indyLedger, genesisTransactions);\n\t\tdelete indyLedger.ledgerUrl;\n\n\t\tledgers.push({\n\t\t\t...indyLedger,\n\t\t\tgenesisTransactions,\n\t\t});\n\t}\n\n\tconst agent = new Agent({\n\t\tconfig: {\n\t\t\t...config,\n\t\t\tindyLedgers: ledgers.map((ledger) => ({\n\t\t\t\t...ledger,\n\t\t\t})),\n\t\t},\n\t\tdependencies: agentDependencies,\n\t});\n\n\treturn agent;\n}\n","import { Agent } from \"@aries-framework/core\";\n\ninterface WithAgent {\n\tagent: Agent;\n}\n\nexport class ServiceWithAgent implements WithAgent {\n\tagent: Agent;\n\n\tconstructor(agent: Agent) {\n\t\tthis.agent = agent;\n\t}\n}\n","import {\n\tConnectionRecord,\n\tOutOfBandRecord,\n} from \"@aries-framework/core\";\nimport { ServiceWithAgent } from \"./baseService\";\n\nexport class AgentService extends ServiceWithAgent {\n\tasync config() {}\n\tasync issueCredential() {}\n\tasync requestCredentialProof() {}\n}\n","import {\n\tAgent,\n\tConnectionRecord,\n\tCredentialState,\n} from \"@aries-framework/core\";\nimport { ServiceWithAgent } from \"./baseService\";\n\nfunction convertToCredentialState(state: string): CredentialState {\n\tswitch (state) {\n\t\tcase \"proposal-sent\":\n\t\t\treturn CredentialState.ProposalSent;\n\t\tcase \"offer-received\":\n\t\t\treturn CredentialState.OfferReceived;\n\t\tcase \"request-sent\":\n\t\t\treturn CredentialState.RequestSent;\n\t\tcase \"credential-received\":\n\t\t\treturn CredentialState.CredentialReceived;\n\t}\n}\n\nexport class CredentialService extends ServiceWithAgent {\n\tasync allCredentials() {\n\t\tconst creds = await this.agent.credentials.getAll();\n\t\treturn creds;\n\t}\n\n\tasync credentialByConnection(connectionOrId: ConnectionRecord | string) {\n\t\tlet connectionRecord: ConnectionRecord;\n\t\tif (typeof connectionOrId === \"string\") {\n\t\t\tconnectionRecord = await this.agent.connections.findById(connectionOrId);\n\t\t} else {\n\t\t\tconnectionRecord = connectionOrId;\n\t\t}\n\n\t\tconst creds = await this.agent.credentials.getAll();\n\t\treturn creds;\n\t}\n}\n","import {\n\tConnectionRecord,\n\tDidExchangeState,\n\tHandshakeProtocol,\n\tOutOfBandRecord,\n} from \"@aries-framework/core\";\nimport { ServiceWithAgent } from \"./baseService\";\n\ntype Maybe<T> = T | null | undefined;\ninterface ConnectionQueryFilter {\n\tstate?: Maybe<DidExchangeState>;\n\tprotocol?: Maybe<HandshakeProtocol>;\n\tisReady?: Maybe<boolean>;\n\tisRequester?: Maybe<boolean>;\n\ttheirDid?: Maybe<string>;\n\ttheirLabel?: Maybe<string>;\n}\n\nexport class ConnectionService extends ServiceWithAgent {\n\t// Creates URL as invitation with encoded JWT payload containing connection metadata.\n\t// Invitation URL can be handled by aries agents.\n\tasync createInvitation(domainUrl: string): Promise<{\n\t\toutOfBandRecord: OutOfBandRecord;\n\t\tinvitationUrl: string;\n\t}> {\n\t\tconst outOfBandRecord =\n\t\t\tawait this.agent.oob.createInvitation();\n\n\t\tconst invitationUrl =\n\t\t\toutOfBandRecord.outOfBandInvitation.toUrl({\n\t\t\t\tdomain: domainUrl,\n\t\t\t});\n\n\t\treturn {\n\t\t\toutOfBandRecord,\n\t\t\tinvitationUrl,\n\t\t};\n\t}\n\n\t// Resolve invitation from URL, created by an aries agent.\n\t// The agent connection will be established by resolving the invitation.\n\t// If `autoAcceptConnections` is set to `true` on the agents config,\n\t// then the connection will be established by this function and the agent isn't requiring an explicit accept of the invitation.\n\tasync receiveInvitation(invitationUrl: string) {\n\t\tconst { connectionRecord } =\n\t\t\tawait this.agent.oob.receiveInvitationFromUrl(\n\t\t\t\tinvitationUrl\n\t\t\t);\n\n\t\treturn connectionRecord;\n\t}\n\n\t// Explicitly accept an invitation from an aries agent.\n\tasync accpetInvitation(invitationUrl: string) {\n\t\tconst { outOfBandRecord } =\n\t\t\tawait this.agent.oob.receiveInvitationFromUrl(\n\t\t\t\tinvitationUrl\n\t\t\t);\n\t\tconst { connectionRecord } =\n\t\t\tawait this.agent.oob.acceptInvitation(\n\t\t\t\toutOfBandRecord.id,\n\t\t\t\t{}\n\t\t\t);\n\n\t\treturn connectionRecord;\n\t}\n\n\t// Retrieve all established connections with the agent.\n\tasync allConnections(filter?: ConnectionQueryFilter) {\n\t\tconst connectionRecords =\n\t\t\tawait this.agent.connections.getAll();\n\n\t\tif (filter) {\n\t\t\treturn connectionRecords.filter((connectionRecord) => {\n\t\t\t\tfor (const key in filter) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tfilter[key] === undefined ||\n\t\t\t\t\t\tfilter[key] !== connectionRecord[key]\n\t\t\t\t\t)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\treturn connectionRecords;\n\t}\n\n\t// Retrieve specific connection with the agent, queried by it's ID.\n\tasync connectionById(\n\t\tconnectionId: string,\n\t\tfilter?: ConnectionQueryFilter\n\t) {\n\t\tconst connectionRecord =\n\t\t\tawait this.agent.connections.findById(connectionId);\n\n\t\treturn connectionRecord;\n\t}\n\n\tasync removeConnection(\n\t\tconnectionOrId: ConnectionRecord | string\n\t) {\n\t\tlet connectionRecord: ConnectionRecord;\n\t\tif (typeof connectionOrId === \"string\") {\n\t\t\tconnectionRecord = await this.agent.connections.findById(\n\t\t\t\tconnectionOrId\n\t\t\t);\n\n\t\t\tif (connectionRecord === null) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[connection.services] Connection record couldn't be found with id '${connectionOrId}'`\n\t\t\t\t);\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tconnectionRecord = connectionOrId;\n\t\t}\n\n\t\t// Deleting connection record from agent storage\n\t\tawait this.agent.connections.deleteById(\n\t\t\tconnectionRecord.id\n\t\t);\n\n\t\treturn true;\n\t}\n}\n"],"mappings":"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","names":["fetch","import_core"]}